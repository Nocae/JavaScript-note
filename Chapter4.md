### 原始值与引用值

ES 变量可以包含两种不同类型的数据：原始值与引用值  
原始值就是**最简单的数据**，引用值则是由**多个值构成的对象**

把一个赋值给变量时，js 引擎必须确定这个值是原始值还是引用值。

- 保存原始值的变量时**按值**访问的，因为我们操作的就是存储在变量中的实际值

引用值是保存在**内存**中的对象，js 不允许直接访问内存位置，不能直接操作对象所在的内存空间。操作对象时，实际上操作的就是对该对象的引用而非实际对象本身，保存引用值的变量时**按引用**访问的

### 动态属性

对于引用值而言，可以随时添加、修改和删除其属性和方法

```js
const person = new Object();
person.name = "Nicholas";
console.log(person.name);
```

在此之后，就可以访问这个对象的新属性，直到对象呗销毁或属性被显式删除

原始值不能有属性，尽管尝试给原始值添加属性不会报错，只有引用值可以动态添加后面可以使用的属性

> 原始类型的初始化可以只使用原始字面量形式，如果使用的是 new 关键字，则 js 会创建一个 Object 类型的实例，但其行为类似原始值。见课本 84

### 复制值

处理存储方式不同，原始值和引用值在通过变量复制时也有所不同，通过变量把一个原始值复制到另一个变量时，原始值会被复制到新变量的位置，两个变量可以**独立使用，互不干扰**

把引用值从一个变量赋值给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置，这里复制的值**实际上是一个指针**，它指向存储在堆内存中的对象。**两个变量实际上指向同一个对象**，因此一个对象上面的变化会在另一个对象上反映出来，他们都指向同一个对象

### 传递参数

ES 中所有函数的参数都是按值传递的意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样

如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样

毕竟变量有按值和按引用访问，而传参则只有按值传递

在按值传递参数时，值会被复制到一个局部变量（arguments 对象中的一个槽位）。按引用传递参数时，值在内存中的位置会被保存在一个局部变量，意味着对本地变量的修改会反应到函数外部

```js
function addTen(num) {
  num += 10;
  return num;
}

let count = 20;
let result = addTen(count);
console.log(count);
console.log(result);
```

局部变量改变不会影响函数外部的原始变量 count，参数 num 和变量 count 互不干扰，如果 num 是按引用传递的，那么 count 的值就会被修改。这个事实在使用数值这张的原始值时是非常明显的

若变量中传递的是对象，就没这么清楚了,如：

```js
function setName(obj) {
  obj.name = "Nicholas";
}

let person = new Object();
setName(person);
console.log(person.name);
```

当函数内部给 obj 设置了 name 属性时，函数外部的对象也会反映这个变化，因为 obj 指向的对象保存在全局作用域的堆内存上。

当局部作用域中修改对象而变化反映到全局时，意味着**参数是按值传递的**，不是按引用传递的

```js
function setName(obj) {
  obj.name = "NIcholas";
  obj = new Object();
  obj.name = "Greg";
}

let person = new Object();
setName(person);
console.log(person.name); // NIcholas
```

详见课本 86 页

### 确定类型

typeof 是判断一个变量是否为字符串、数值、布尔值或 undefined 的最好方式

如果值是**对象或 null，那么 typeof 返回"Object"**

```js
let s = "Nicholas";
let b = true;
let i = 22;
let u;
let n = null;
let o = new Object();

console.log(typeof s); // string
console.log(typeof i); // number
console.log(typeof b); // boolean
console.log(typeof u); // undefined
console.log(typeof n); // Object
console.log(typeof o); // Object
```

ES 提供了 instanceof 操作符用来判断一个值是什么类型的对象

```js
result = variable instanceof constructor;
```

如果变量是给定引用类型，则 instanceof 操作符返回 true

```js
console.log(person instanceof Object); // 变量person是Object吗？
console.log(colors instanceof Array); // 变量colors是Array吗？
console.log(pattern instanceof RegExp); // 变量pattern是RegExp吗？
```

通过 instanceof 操作符检测任何引用值和 Object 构造函数都会返回 true。如果用 instanceof 检测原始值，，始终返回 false，因为原始值不是对象

### 执行上下文与作用域

[JavaScript 中的执行上下文](https://segmentfault.com/a/1190000018001052)

[Arguments 对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments)

执行上下文的概念在 js 中颇为重要。变量或函数的上下文决定了它们可以访问哪些数据，以及他们的行为。每个上下文都有一个关联的**变量对象**，而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台数据会用到它

全局上下文是最外层的上下文，根据 ES 实现宿主环境，表示全局上下文的对象可能不一样。浏览器中，就是常说的 window 对象，所有通过 var 定义的全局变量和函数都会成为 window 对象的属性和方法。使用 let 和 const 的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。上下文在其所有代码都执行完毕后会被销毁，包括定义在上面的所有变量和函数（全局上下文在应用程序退出前才会被销毁，如关闭网页或浏览器）

每个函数调用都有自己的上下文。代码执行流进入函数时，函数的上下文被推到一个上下文栈上。函数执行完毕后，上下文栈弹出该函数上下文，控制权返还给之前的执行上下文。ES 程序的执行流就是通过这个上下文栈控制的

上下文中的代码在执行时，会创建变量对象的一个**作用域链**，这个作用域链决定了上下文的代码在**访问变量和函数时的顺序**。代码**正在执行**的上下文的变量对象**始终位于作用域链的最前端**。

如上下文是函数，则其活动对象用作变量对象，活动对象最初只有一个定义变量：arguments

详见课本 88 页

> 内部上下文通过作用域链访问外部上下文中的一切，外部上下文无法访问内部上下文中的任何东西。上下文之间是线性的，有序的。每个上下文都可以到上一级上下文中去搜索变量和函数，任何上下文都不能到下一级上下文中去搜索

### 作用域链增强

某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。通常在如下两种情况：

- try/catch 语句的 catch 块
- with 语句

对于 with 语句来说，会向作用域链前端添加指定的对象；对 catch 语句而言，会创建一个新的变量对象，这个变量对象会包含要抛出错误对象的声明

### 变量声明

#### 使用 var 的函数作用域声明

var 声明变量时，变量会被自动添加到最接近的上下文。最接近的上下文就是函数的局部上下文。在 with 语句中，最接近的上下文也是函数的局部上下文。

**变量未经声明就被初始化了，那么它就会自动被添加到全局上下文**。

```js
function add(num1, num2) {
  var sum = num2 + num1;
  return sum;
}

let result = add(10, 20);
console.log(sum); // ReferenceError: sum is not defined
```

如果省略上面的关键字 var，那么 sum 在 add()被调用之后就可以变成可以访问的了

> 未经声明而初始化变量是 js 编程紫红一个非常常见的错误，会导致很多问题。严格模式下未经声明就初始化变量会报错

var 声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。这个现象叫做“提升（**hoisting**）”。提升让同一作用域内代码不必考虑变量是否已经声明就可以直接使用。实践中，提升也会导致合法却奇怪的现象，在变量声明之前使用变量。

#### 使用 let 的块级作用域声明

ES6 新增的 let 关键字跟 var 很相似，但它的作用域是块级的，这也是 js 中的新概念。

块级作用域由最近的一对包含花括号{}界定。if、while、function，甚至连单独的块也是 let 声明变量的作用域

- let 与 var 的行为非常适合在循环中声明迭代变量。使用 var 声明的迭代变量会泄露到循环外部，这种情况应该避免。

```js
for (var i = 0; i < 10; i++) {}
console.log(i); // 10
```

严格来说，let 在 js 运行时也会被提升，但由于“暂时性死区”的缘故，实际上不能在声明变量之前使用 let 变量。let 的提升跟 var 是不一样的

#### 使用 const 的常量声明

ES6 同时增加了 const 关键字。使用 const 声明的变量必须同时初始化为某个值

一经声明，在其生命周期的任何时候都不能在重新赋予新值

- const 声明之应用到顶级原语或对象。赋值为对象的 const 变量不能再被重新赋值为其他引用值，但对象的键不受限制

```js
const o1 = {};
o1 = {}; // TypeError: Assignment to constant variable.

const o2 = {};
o2.name = "Jake";
console.log(o2.name); // Jake
```

- 如果想让整个对象都不能修改，可以使用 Object.freeze(),这样再给属性赋值时虽然不会报错，但会静默失败

```js
const o3 = Object.freeze({});
o3.name = "Jake";
console.log(o3.name); // undefined
```

由于 const 声明暗示变量的值是单一类型且不可修改，js 运行时编译器可以将所有实例都替换成实际的值，而不会通过查询表进行变量查找

> 开发实践表明，如果开发流程不会因此受很大影响，应该尽可能多的使用 const 声明，除非确实需要一个将来会重新赋值的变量。这样可以从根本上保证提前发现重新赋值导致的 bug

#### 标识符查找

在特定上下文中为读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么。

如果局部上下文中没有找到该标识符，则搜索停止，变量确定；若没有找到变量名，则继续沿作用域链搜索。一直持续到搜索全局上下文的变量对象，如果仍然没有找到，说明未声明

对于搜索过程而言，引用局部变量会让搜索自动停止。如果局部上下文中有一个同名的标识符，就不能再该上下文中引用父上下文中的同名标识符

使用块级作用域不会改变搜索流程，但可以给词法层级添加额外的层次

### 垃圾回收

#### 标记清理

最常用的垃圾回收策略就是标记清理

详见课本 95 页

#### 引用计数

详见课本 95 页

#### 内存管理

将内存占用保持在一个较小的值可以让页面性能更好。优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。

若数据不再必要，将它设置为 null，释放其引用。可以叫做解除引用，建议最适合全局变量和全局对象的属性，局部变量在超出作用域后会被自动解除引用

> 解除对一个值得引用并不会自动导致相关内存被回收，解除引用的关键在于确保相关的值已经不在上下文里了，因此它在下次垃圾回收时会被回收

##### 通过 const 和 let 声明提升性能

ES6 增加这两个关键字不仅有助于改善代码风格，而且同样有助于改进垃圾回收的过程

因为它们都以块为作用域，所以相比于使用 var，使用这两个新关键字可能会更早的让垃圾回收程序介入，尽早回收应该回收的内存。

在块作用域比函数作用域更早终止的情况下，很有可能发生

##### 隐藏类和删除操作

V8 在将解释后的 js 代码编译为实际的机器码时会利用“隐藏类”，如果代码非常注重性能，这点很重要

运行期间，V8 会将创建的对象与隐藏类关联起来，以跟踪他们的属性特征。能够共享相同隐藏类的对象性能会更好

避免 js 的“先创建再补充”式的动态属性赋值，并在构造函数中一次性声明所有属性

```js
function Article(opt_author) {
  this.title = "INaug";
  this.author = opt_author;
}

let a1 = new Article();
let a2 = new Article("Jake");
```

要注意的是，使用 delete 关键字会导致生成相同的隐藏类片段，即使两个实例使用了同一个构造函数，它们也不再共享一个隐藏类。

**动态删除属性和动态添加属性导致的后果一样**，最佳实践是把不想要的属性设置为 null，可以保持隐藏类不变和继续共享，同时也能达到删除引用值供垃圾回收程序回收的效果

##### 内存泄漏

[学习 Javascript 闭包（Closure）](http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html)

内存泄漏大部分是由不合理的引用导致的

- 以外声明全局变量是最常见但也最容易修复的内存泄漏问题

- 定时器也可能会悄悄地导致内存泄漏

- 使用 js 闭包很容易在不知不觉间造成内存泄漏

详见课本 99 页

##### 静态分配与对象池

详见课本 100 页
